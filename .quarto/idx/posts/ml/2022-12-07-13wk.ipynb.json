{"title":"A1: 깊은복사와 얕은복사 (12주차)","markdown":{"yaml":{"title":"A1: 깊은복사와 얕은복사 (12주차)","author":"SEOYEON CHOI","date":"2022-12-07","categories":["Special Topics in Machine Learning","깊은복사","얕은복사"]},"headingText":"Introduction","containsRefs":false,"markdown":"\n\n> copy\n\n\n# 비상식적인 append\n\n`-` 아래의 코드를 관찰하자.\n\n현재 a,b의 출력결과는?\n\n`-` 이제 다시 아래의 코드를 관찰하자.\n\n# append의 동작원리: 틀린상상\n\n`-` 아래의 코드를 다시 살펴보자.\n\na,b라는 변수들은 메모리에 어떻게 저장이 되어있을까?\n\n상상력을 조금 발휘하면 아래와 같이 여길 수 있다.\n\n1. 메모리는 변수를 담을 방이 여러개 있는 호텔이라고 생각하자.\n\n2. 아래를 실행하였을 경우\n\n- 메모리주소1에 존재하는 방을 a라고 하고, 그 방에 [1,2,3]을 넣는다.\n\n3. 아래를 실행하였을 경우\n\n- 메모리주소2에 존재하는 방을 b라고 하고, 그 방에 a를 넣어야하는데, a는 [1,2,3]이니까 [1,2,3]을 넣는다.\n\n4. 아래를 실행하면\n\n- 방 a로가서 [1,2,3]을 [1,2,3,4]로 바꾼다.\n\n- 그리고 방 b에는 아무것도 하지 않는다.\n\n`-` R에서는 맞는 비유인데, 파이썬은 적절하지 않은 비유이다.\n\n## 틀린이유\n\n실제로는 a,b가 저장된 메모리 주소가 동일함\n\n# append의 동작원리: 올바른 상상\n\n`-` 파이썬에서는 아래가 더 적절한 비유이다.\n\n1. 메모리는 변수를 담을 방이 여러개 있는 호텔이라고 생각하자.\n\n2. 아래를 실행하였을 경우\n\n- 메모리주소 `139753545242336`에서 [1,2,3]을 생성\n- 방 `139753545242336`의 방문에 a라는 포스트잇을 붙인다.\n- 앞으로 [1,2,3]에 접근하기 위해서는 여러 메모리방중에서 a라는 포스트잇이 붙은 방을 찾아가면 된다.\n\n3. 아래를 실행하였을 경우\n\n- a라는 포스트잇이 있는데, `a`라는 포스트잇이랑 b라는 포스트잇과 같은 효과를 주도록 한다.\n- 쉽게말하면 b라는 포스트잇을 방 `139753545242336`의 방문에 붙인다는 이야기.\n- 앞으로 [1,2,3]에 접근하기 위해서는 여러 메모리방중에서 a라는 포스트잇이 붙어 있거나 b라는 포스트잇이 붙어있는 방을 찾아가면 된다.\n\n4. 아래를 실행하면\n\n- `a`라는 포스트잇이 붙어있는 방으로 가서, 그 내용물에 append함수를 적용하여 4를 추가하라. 즉 내용물 [1,2,3]을 [1,2,3,4]로 바꾸라.\n- 같은방(`139753545242336`)에 a,b라는 포스트잇이 모두 붙어있음. 따라서 b라는 포스트잇이 붙은 방을 찾아가서 내용물을 열어보면 [1,2,3,4]가 나온다.\n\n# 할당문(=)의 이해\n\n`-` 파이썬에서 할당문을 이해하기 위해서는 언제나 오른쪽을 먼저 읽어야 한다. \n\n`-` 할당문의 오른쪽에서는 객체를 생성하거나 가져옴 - 그 후에 라벨을 붙이듯이 할당문 왼쪽의 변수가 할당문 오른쪽의 객체에 바인딩 된다. (참조)\n\n`-` `b=a`는\n\n> 나는 이미 a가 의미하는게 무엇인지 알고있어. 그런데 그 실체를 b라고도 부르고 싶어. $\\to$ 참조\n\n라는 것과 같다. 즉 이미 a라고 부르고 있는것을 내가 b라고도 부르고 싶다는 의미인데 이는 마치 별명과 같다. (b는 a의 별명, alias) 그리고 이처럼 하나의 오브젝트에 여러개의 이름을 붙이는 것을 에일리어싱이라고 부른다.\n\n# id, value\n\n## 예제1\n\n여기에서 a,b,c는 모두 같은 value를 가진다.\n\n하지만 그 id까지 같은 것은 아니다.\n\n## 예제2\n\n`a`를 다시 정의한 것이라 보면 될 듯\n\n# 이터닝\n\n## 예제1\n\n일단 할당\n\n독립적으로 오브젝트 만들었으니 id가 다르지\n\n## 예제2: 이제 다 이해했다고 생각했는데..\n\n이게 왜 똑같지..?\n\n(해설) 파이썬의 경우 효율성을 위해서 -5~256까지의 정수를 미리 저장해둠.\n\n# `.copy()`의 사용 (shallow copy의 사용)\n\n## 예제1\n\n- 아래의 예제를 살펴보자. (참조를 제대로 이해했다면 아래의 예제는 자연스럽게 이해가능)\n\n## 예제2: R과 같이 = 를 쓰고 싶다면?\n\n주소 달라짐!!\n\n## 예제3: 이제 다 이해했다고 생각했는데..\n\n- 이제 다 이해했다고 생각했는데..\n\n왜 또 참조한것마냥 l1과 l2가 같이 바뀌고 있지?\n\n# Shallow copy의 이해\n\n- 방금 살펴본 예제3을 이해하기 위해서는 shallow copy를 이해해야 한다.\n\n## 예제1\n\n메모리 상황\n\n1. 2222라는 오브젝트가 어떤공간(id(a): `139753545300880`)에 생성되고 그 공간에 `a`라는 라벨이 붙음\n2. 2222라는 오브젝트가 어떤공간(id(b): `139753545300880`)에 생성되고 그 공간에 `b`라는 라벨이 붙음\n\n즉 -5~256 이외의 2개의 메모리 공간을 추가적으로 사용\n\n## 예제2\n\n메모리 공간에 1,2는 이미 저장되어 있어서 생성할 필요 없고 2022만 메모리 공간에 생성하면 된다.\n\n메모리상황\n\n0. -5~256까지의 숫자는 미리 메모리에 저장되어 있다.(`이터닝`) 이중에서 1은 id(a[0]): `7394656`, 2는 id(a[1]): `7394688`에 저장되어있음.\n1. 2222가 공간 id(a[2]): `139753178093776`에서 만들어진다.\n2. 어떠한 리스트오브젝트가 공간 id(a): `139753182327904`에서 만들어지고 원소로 [1,2,2222]를 가진다. 이 공간에 a라는 포스트잇을 붙인다.\n3. 2222가 공간 id(a)[2]: `139753178095568`에서 만들어진다.\n4. 어떠한 리스트오브젝트가 공간 id(b): `139753173818656`에서 만들어지고 원소로 [1,2,2222]를 가진다. 이 공간에 b라는 포스트잇을 붙인다.\n5. a라는 포스트잇이 붙은 공간으로 이동하여 원소에 4를 추가시킨다.\n\n즉 -5~256이외에 4개의 메모리 공간을 추가사용 (a,b,a의 2222,b의 2222)\n\n## 예제3\n\n메모리상황 \n\n0. -5~256까지의 숫자가 메모리에 저장되어 있다. \n1. 저장된 숫자중 66,55,44를 묶어서 리스트로 구성하고 이 리스트를 공간 id(l1[1]): `139753183707216`에 저장. \n2. 숫자 3과 공간 id(l1[1]): `139753183707216`에 저장된 리스트 [66,55,44]를 하나로 묶어서 새로운 리스트를 구성하고 이를 공간 id(l1): `139753183437040`에 저장. 공간 id(l1): `139753183437040`에 `l1`이라는 포스트잇 생성. \n3. 공간 id(l2): `139753182311120`에 `l1`의 원소들을 모아서 새로운 리스트를 구성함. 공간 id(l2): `139753182311120`에 `l2`라는 포스트잇 생성. \n\n0. l1[0]은 원래 공간 `7394720`와 binding 되어 있었음.  \n1. 그런데 7777이라는 새로운 오브젝트가 공간 id(l1): `139753178092080`에 생성되고 l1[0]이 공간 `139753178092080`와 다시 binding 됨. \n\n## 예제4\n\n> 예제3, 예제4를 통하여 리스트가 가변형객체라는 것을 확인할 수 있다. 예제3의 경우 l1이 저장되어있던 메모리공간의 내용물이 [3,[66,55,44]] 에서 [7777,[66,55,44]] 로 바뀌었다. 예제4의 경우 l1이 저장되어있던 메모리공간의 내용물이 [3,[66,55,44]] 에서 [3,[66,55,44],7777] 로 바뀌었다. \n\n## 예제5: 우리를 힘들게 했던 그 예제. \n\n(시점1)\n\n(시점2)\n\nl1[1]의 묶음방식이 저장된 공간에 7777 추가할 거야\n\n해설: 사실 시점1에서 메모리 주소상황을 잘 이해했다면 신기한 일이 아니다. `.copy()`는 l1과 l2의 주소만 다르게 만들 뿐 내용물인 `l1[0]`,`l1[1]`는 동일하니까.\n\n## 예제6: 신임교수=['최규빈','이영미']\n\n`-` 최규빈, 이영미는 신임교수임 \n\n`-` 신임교수를 누군가는 막내들이라고 부르기도 함. \n\n참조\n\n\"막내들\"이라는 단어와 \"신임교수\"라는 단어는 사실 같은 말임 \n\n여기까지 참조 설명\n\n`-` 새로운 교수 \"박혜원\"이 뽑혔음. \n\n`-` 전북대 통계학과에서 R특강팀을 구성하여 방학중 R교육을 실시하고자함. 특강팀은 우선 신임교수들로 구성. \n\n`-` R특강팀에 `최혜미`교수님 추가. (그렇지만 최혜미교수님이 막내는 아니야.. // 참조와 shallow copy의 차이점) \n\n`-` R특강팀에서 양성준 교수를 추가하여 파이썬 특강팀을 구성 \n\n`-` 이영미교수는 다른 일이 많아서 R특강 팀에서 제외됨. (그럼 자연히 파이썬에서도 제외됨!!) \n\n하지만 이영미교수는 여전히 신임교수이면서 막내들임 \n\n`-` 새로운 교수로 \"손흥민\"이 임용됨. \n\n`-` 그렇다고 해서 손흥민 교수가 바로 R이나 파이썬 특강팀에 자동소속되는건 아님\n\nshallow copy로 id 주소가 각각 할당되었기 때문\n\n# Deep copy\n\n## 예제1: Motivation example\n\n`-` 아래의 상황을 다시 생각해보자.\n\n**이슈:** 이영미교수가 파이썬특강에서 제외되면서 ADSP특강팀에서도 제외되었음. 그런데 사실 이영미교수가 파이썬특강팀에서만 제외되길 원한 것이지 ADSP특강팀에서 제외되길 원한게 아닐수도 있음. \n\n**해결**: Deep copy의 사용\n\n패키지 필요\n\n## 예제2\n\n`-` deepcopy\n\n묶음 방식이 달라지면서 다른 주소가 할당된 모습\n\n`-` 비교를 위한 shallow copy\n\n`-` 비교를 위한 참조 \n\n주소 다 똑같아\n\n# Shallow copy 연습문제 \n\n## 예제1\n\n`-` 아래의 코드결과를 예측하라. 결과가 나오는 이유를 설명하라. \n\nshallow copy 썼으니까 같이 추가된 모습\n\n## 예제2\n\n`-` 아래의 코드결과를 예측하라. 결과가 나오는 이유를 설명하라. \n\nl1에 재할당한 것이라 생각하면 된다.\n\n## 예제3\n\n## 예제4\n\n(잘못된 상상) 아래의 코드와 결과가 같을거야!!\n\n(하지만 현실은)\n\n재할당의 개념이 있었기 때문에 주소가 다른게 할당된 것이고, 결국 다른 결과가 나온다.\n\n## 예제5\n\n주소는 다르지만 재할당의 개념이 없어!\n\nl1에 append 하는 식으로 되어서 묶음 방식이 같이 움직인다.\n\n> ??? 예제4랑 예제5는 같은코드가 아니었음!!! `a += [1]` 는 새로운 오브젝트를 만드는게 아니고, 기존의 오브젝트를 변형하는 스타일의 코드였음! (마치 append 메소드처럼) \n\n# 불변형 객체 \n\n## Motivation example\n\n`-` 우리는 이제 아래의 내용은 마스터함 \n\n`-` 아래의 결과를 한번 예측해볼까? \n\n이번엔 튜플로\n\n## 해설 \n\n(시점1)\n\n이번엔 리스트 안에 튜플을 넣어봄\n\n(시점2)\n\n주소 `139753182280032`에 있는 값을 바꾸고 싶지만 불변형이라 못바꿈 $\\to$ 그냥 새로 만들자. 그래서 그걸 `139753174874064`에 저장하자. \n\n튜플의 묶음 방식은 불변형! 정의: 값을 변환할 수 없는 오브젝트다~ 새로 오브젝트 만들어 저장함.\n\n리스트 : 값을 바꿀 수 있는 오브젝트다, 묶음 방식을 바꿀 수 있다.\n\n# Shallow copy vs Deep copy\n\n`-` 암기용문구: \"shallow copy는 껍데기만 복사한다. deep copy는 내부까지 복사한다.\"\n\n`-` 일부교재에서는 경우에 따라 shallow copy가 선호될 수 있다는 식으로 설명되어있으나 솔직히 대부분 코드에서 shallow copy의 동작을 의도하고 코드를 사용하진 않는다. 대부분의 경우에서 shallow copy는 불필요한 side effect을 유발하는 쓸모없는 개념이라 생각한다. \n\n`-` 그럼 shallow copy의 장점은 무엇인가? shallow copy가 deep copy보다 메모리를 더 적게 사용한다. \n\n```Python\n## 예제1\nlst1 = ['양성준',['최규빈','이영미','최혜미']]\nlst2 = lst1.copy()\n## 예제2 \nlst1 = ['양성준',['최규빈','이영미','최혜미']]\nlst2 = copy.deepcopy(lst1)\n```\n\n- 예제1: 4+1+2 = 7개의 공간 사용 \n- 예제2: 4+2+2 = 8개의 공간 사용 \n\n`-` 분노: 참조인지 카피인지 구분하는것도 힘든데, 카피도 shallow 인지 deep 인지 구분해서 사용해야해? 겨우 저 메모리때문에? \n\n**요약**\n\n`-` 파이썬은 메모리를 아끼기 위해서 shallow copy라는 이상한 행동을 한다. \n\n`-` 통찰1: 그런데 오묘하게도 [1,2,3,4,5,6]와 같이 중첩된 리스트가 아니라면 문제가 되지 않음. (***메모리는 아끼면서 문제가 되지 않는다?? 천재인데??***) \n\n-  중첩된 리스트가 아닐 경우는 `shallow copy = deep copy` 임.\n\n1차원이면 이런 문제 생기지 않지, 하지만 모든 데이터가 1차원?\n\n`-` 통찰2: 생각해보니까 모든 자료형이 불변형인 경우에도 문제가 되지 않음. (R은 모든 자료형이 불변형이다) \n\n`-` 문제상황요약: [[1,2],[3,4]] 와 같이 리스트에 리스트가 포함된 형태라면 문제가 생긴다. (이건 개선이 필요함) \n- 개선1: 깊은복사(import copy)\n- 개선2: 넘파이\n\n# numpy \n\n## 2차원의 실체\n\n`-` 2차원 array a,b를 선언하자. \n\n`-` a,b,c,d 속성비교 \n\n`-` strides는 무엇? \n\n- strides: (다음 행으로 가기위해서 JUMP해야하는 메모리 공간수, 다음 열로 가기위해서 JUMP해야하는 메모리 공간수) \n\n`-` 사실 a,b,c,d 는 모두 1차원으로 저장되어있음. (중첩된 리스트꼴이 아니라)\n\nshape이나 strides 등의 옵션으로 1차원이 아니게 보여지는 것 뿐\n\n## 참조 \n\n`-` a를 선언, b는 a의 참조\n\n`-` a의 shape을 바꾸어보자 $\\to$ b도 같이 바뀐다 \n\n## view \n\n`-` a를 선언, b는 a의 view\n\nview가 shallow copy 같은 이유 껍데기 주소만 복사해옴, 공간에 대한 주소는 같지 않음\n\n`-` 그런데.. \n\n`-` 출생의 비밀 \n\n- ? 이거 바뀐 a아니야? \n\n`-` View \n- b가 a의 뷰라는 의미는, b가 a를 소스로하여 만들어진 오브젝트란 의미이다. \n- 따라서 이때 b.base는 a가 된다. \n- b는 자체적으로 데이터를 가지고 있지 않으며 a와 공유한다. \n- 이러한 의미에서 view를 shallow copy 라고 부른다. (stride, shape과 같은 껍데기만 새로 생성, base는 유지) \n\n`note1` 원본 ndarray의 일 경우는 .base가 None으로 나온다. \n\n`note2` b.base의 shpae과 b의 shape은 아무 관련없다. \n\n## copy \n\n`-` a를 선언, b는 a의 copy\n\n`-` a의 shape을 바꿔도 b에는 적용되지 않음 \n\n`-` 그리고 a[0]의 값을 바꿔도 b에는 적용되지 않음. \n\n`-` b의 출생을 조사해보니.. \n\n출생의 비밀은 없었다. 둘다 원본. \n\n`-` `.view()` 는 껍데기만, `.copy()` 는 껍데기 + base 까지 새로생성 \n\n### ***Appendix: .copy의 한계(?)***\n\n***해결책: 더 깊은 복사***\n\n`-` 중간요약\n\n- 사실 `.copy()`는 온전한 deep copy 가 아니라 level 2 deep copy 이다. \n- 따라서 `.copy()`는 base의 정보를 shallow copy 한다 (level 1 deep copy 한다.)\n- 그래서 base가 다시 중첩구조를 가지는 경우는 온전한 deep-copy가 수행되지 않는다. \n- 그런데 일반적으로 넘파이를 이용할때 자주 사용하는 데이터 구조인 행렬, 텐서등은 base가 중첩구조를 가지지 않는다. (1차원 array로만 저장되어 있음) \n- 따라서 행렬, 텐서에 한정하면 `.copy()`는 온전한 deep copy라고 이해해도 무방하다. \n\n행/열 같지 않으면 numpy쓰면 힘들걸..\n\n모든 데이터 구조가 2차원까지로 정리 된다.\n\n## 별명, 뷰, 카피 \n\n`-` test 함수 작성 \n\n`-` 잘 동작하나? \n\n(테스트1) \n\n참조\n\n(테스트2) \n\n(테스트3) \n\n(테스트4) \n\n## 결론 \n\n`-` 우리가 사용했던 어떠한 것들이 뷰가 나올지 카피가 나올지 사실 잘 모른다. (그래서 원리를 이해해도 대응할 방법이 사실없음) \n\n### 예시1\n\n### 예시2\n","srcMarkdownNoYaml":"\n\n> copy\n\n# Introduction\n\n# 비상식적인 append\n\n`-` 아래의 코드를 관찰하자.\n\n현재 a,b의 출력결과는?\n\n`-` 이제 다시 아래의 코드를 관찰하자.\n\n# append의 동작원리: 틀린상상\n\n`-` 아래의 코드를 다시 살펴보자.\n\na,b라는 변수들은 메모리에 어떻게 저장이 되어있을까?\n\n상상력을 조금 발휘하면 아래와 같이 여길 수 있다.\n\n1. 메모리는 변수를 담을 방이 여러개 있는 호텔이라고 생각하자.\n\n2. 아래를 실행하였을 경우\n\n- 메모리주소1에 존재하는 방을 a라고 하고, 그 방에 [1,2,3]을 넣는다.\n\n3. 아래를 실행하였을 경우\n\n- 메모리주소2에 존재하는 방을 b라고 하고, 그 방에 a를 넣어야하는데, a는 [1,2,3]이니까 [1,2,3]을 넣는다.\n\n4. 아래를 실행하면\n\n- 방 a로가서 [1,2,3]을 [1,2,3,4]로 바꾼다.\n\n- 그리고 방 b에는 아무것도 하지 않는다.\n\n`-` R에서는 맞는 비유인데, 파이썬은 적절하지 않은 비유이다.\n\n## 틀린이유\n\n실제로는 a,b가 저장된 메모리 주소가 동일함\n\n# append의 동작원리: 올바른 상상\n\n`-` 파이썬에서는 아래가 더 적절한 비유이다.\n\n1. 메모리는 변수를 담을 방이 여러개 있는 호텔이라고 생각하자.\n\n2. 아래를 실행하였을 경우\n\n- 메모리주소 `139753545242336`에서 [1,2,3]을 생성\n- 방 `139753545242336`의 방문에 a라는 포스트잇을 붙인다.\n- 앞으로 [1,2,3]에 접근하기 위해서는 여러 메모리방중에서 a라는 포스트잇이 붙은 방을 찾아가면 된다.\n\n3. 아래를 실행하였을 경우\n\n- a라는 포스트잇이 있는데, `a`라는 포스트잇이랑 b라는 포스트잇과 같은 효과를 주도록 한다.\n- 쉽게말하면 b라는 포스트잇을 방 `139753545242336`의 방문에 붙인다는 이야기.\n- 앞으로 [1,2,3]에 접근하기 위해서는 여러 메모리방중에서 a라는 포스트잇이 붙어 있거나 b라는 포스트잇이 붙어있는 방을 찾아가면 된다.\n\n4. 아래를 실행하면\n\n- `a`라는 포스트잇이 붙어있는 방으로 가서, 그 내용물에 append함수를 적용하여 4를 추가하라. 즉 내용물 [1,2,3]을 [1,2,3,4]로 바꾸라.\n- 같은방(`139753545242336`)에 a,b라는 포스트잇이 모두 붙어있음. 따라서 b라는 포스트잇이 붙은 방을 찾아가서 내용물을 열어보면 [1,2,3,4]가 나온다.\n\n# 할당문(=)의 이해\n\n`-` 파이썬에서 할당문을 이해하기 위해서는 언제나 오른쪽을 먼저 읽어야 한다. \n\n`-` 할당문의 오른쪽에서는 객체를 생성하거나 가져옴 - 그 후에 라벨을 붙이듯이 할당문 왼쪽의 변수가 할당문 오른쪽의 객체에 바인딩 된다. (참조)\n\n`-` `b=a`는\n\n> 나는 이미 a가 의미하는게 무엇인지 알고있어. 그런데 그 실체를 b라고도 부르고 싶어. $\\to$ 참조\n\n라는 것과 같다. 즉 이미 a라고 부르고 있는것을 내가 b라고도 부르고 싶다는 의미인데 이는 마치 별명과 같다. (b는 a의 별명, alias) 그리고 이처럼 하나의 오브젝트에 여러개의 이름을 붙이는 것을 에일리어싱이라고 부른다.\n\n# id, value\n\n## 예제1\n\n여기에서 a,b,c는 모두 같은 value를 가진다.\n\n하지만 그 id까지 같은 것은 아니다.\n\n## 예제2\n\n`a`를 다시 정의한 것이라 보면 될 듯\n\n# 이터닝\n\n## 예제1\n\n일단 할당\n\n독립적으로 오브젝트 만들었으니 id가 다르지\n\n## 예제2: 이제 다 이해했다고 생각했는데..\n\n이게 왜 똑같지..?\n\n(해설) 파이썬의 경우 효율성을 위해서 -5~256까지의 정수를 미리 저장해둠.\n\n# `.copy()`의 사용 (shallow copy의 사용)\n\n## 예제1\n\n- 아래의 예제를 살펴보자. (참조를 제대로 이해했다면 아래의 예제는 자연스럽게 이해가능)\n\n## 예제2: R과 같이 = 를 쓰고 싶다면?\n\n주소 달라짐!!\n\n## 예제3: 이제 다 이해했다고 생각했는데..\n\n- 이제 다 이해했다고 생각했는데..\n\n왜 또 참조한것마냥 l1과 l2가 같이 바뀌고 있지?\n\n# Shallow copy의 이해\n\n- 방금 살펴본 예제3을 이해하기 위해서는 shallow copy를 이해해야 한다.\n\n## 예제1\n\n메모리 상황\n\n1. 2222라는 오브젝트가 어떤공간(id(a): `139753545300880`)에 생성되고 그 공간에 `a`라는 라벨이 붙음\n2. 2222라는 오브젝트가 어떤공간(id(b): `139753545300880`)에 생성되고 그 공간에 `b`라는 라벨이 붙음\n\n즉 -5~256 이외의 2개의 메모리 공간을 추가적으로 사용\n\n## 예제2\n\n메모리 공간에 1,2는 이미 저장되어 있어서 생성할 필요 없고 2022만 메모리 공간에 생성하면 된다.\n\n메모리상황\n\n0. -5~256까지의 숫자는 미리 메모리에 저장되어 있다.(`이터닝`) 이중에서 1은 id(a[0]): `7394656`, 2는 id(a[1]): `7394688`에 저장되어있음.\n1. 2222가 공간 id(a[2]): `139753178093776`에서 만들어진다.\n2. 어떠한 리스트오브젝트가 공간 id(a): `139753182327904`에서 만들어지고 원소로 [1,2,2222]를 가진다. 이 공간에 a라는 포스트잇을 붙인다.\n3. 2222가 공간 id(a)[2]: `139753178095568`에서 만들어진다.\n4. 어떠한 리스트오브젝트가 공간 id(b): `139753173818656`에서 만들어지고 원소로 [1,2,2222]를 가진다. 이 공간에 b라는 포스트잇을 붙인다.\n5. a라는 포스트잇이 붙은 공간으로 이동하여 원소에 4를 추가시킨다.\n\n즉 -5~256이외에 4개의 메모리 공간을 추가사용 (a,b,a의 2222,b의 2222)\n\n## 예제3\n\n메모리상황 \n\n0. -5~256까지의 숫자가 메모리에 저장되어 있다. \n1. 저장된 숫자중 66,55,44를 묶어서 리스트로 구성하고 이 리스트를 공간 id(l1[1]): `139753183707216`에 저장. \n2. 숫자 3과 공간 id(l1[1]): `139753183707216`에 저장된 리스트 [66,55,44]를 하나로 묶어서 새로운 리스트를 구성하고 이를 공간 id(l1): `139753183437040`에 저장. 공간 id(l1): `139753183437040`에 `l1`이라는 포스트잇 생성. \n3. 공간 id(l2): `139753182311120`에 `l1`의 원소들을 모아서 새로운 리스트를 구성함. 공간 id(l2): `139753182311120`에 `l2`라는 포스트잇 생성. \n\n0. l1[0]은 원래 공간 `7394720`와 binding 되어 있었음.  \n1. 그런데 7777이라는 새로운 오브젝트가 공간 id(l1): `139753178092080`에 생성되고 l1[0]이 공간 `139753178092080`와 다시 binding 됨. \n\n## 예제4\n\n> 예제3, 예제4를 통하여 리스트가 가변형객체라는 것을 확인할 수 있다. 예제3의 경우 l1이 저장되어있던 메모리공간의 내용물이 [3,[66,55,44]] 에서 [7777,[66,55,44]] 로 바뀌었다. 예제4의 경우 l1이 저장되어있던 메모리공간의 내용물이 [3,[66,55,44]] 에서 [3,[66,55,44],7777] 로 바뀌었다. \n\n## 예제5: 우리를 힘들게 했던 그 예제. \n\n(시점1)\n\n(시점2)\n\nl1[1]의 묶음방식이 저장된 공간에 7777 추가할 거야\n\n해설: 사실 시점1에서 메모리 주소상황을 잘 이해했다면 신기한 일이 아니다. `.copy()`는 l1과 l2의 주소만 다르게 만들 뿐 내용물인 `l1[0]`,`l1[1]`는 동일하니까.\n\n## 예제6: 신임교수=['최규빈','이영미']\n\n`-` 최규빈, 이영미는 신임교수임 \n\n`-` 신임교수를 누군가는 막내들이라고 부르기도 함. \n\n참조\n\n\"막내들\"이라는 단어와 \"신임교수\"라는 단어는 사실 같은 말임 \n\n여기까지 참조 설명\n\n`-` 새로운 교수 \"박혜원\"이 뽑혔음. \n\n`-` 전북대 통계학과에서 R특강팀을 구성하여 방학중 R교육을 실시하고자함. 특강팀은 우선 신임교수들로 구성. \n\n`-` R특강팀에 `최혜미`교수님 추가. (그렇지만 최혜미교수님이 막내는 아니야.. // 참조와 shallow copy의 차이점) \n\n`-` R특강팀에서 양성준 교수를 추가하여 파이썬 특강팀을 구성 \n\n`-` 이영미교수는 다른 일이 많아서 R특강 팀에서 제외됨. (그럼 자연히 파이썬에서도 제외됨!!) \n\n하지만 이영미교수는 여전히 신임교수이면서 막내들임 \n\n`-` 새로운 교수로 \"손흥민\"이 임용됨. \n\n`-` 그렇다고 해서 손흥민 교수가 바로 R이나 파이썬 특강팀에 자동소속되는건 아님\n\nshallow copy로 id 주소가 각각 할당되었기 때문\n\n# Deep copy\n\n## 예제1: Motivation example\n\n`-` 아래의 상황을 다시 생각해보자.\n\n**이슈:** 이영미교수가 파이썬특강에서 제외되면서 ADSP특강팀에서도 제외되었음. 그런데 사실 이영미교수가 파이썬특강팀에서만 제외되길 원한 것이지 ADSP특강팀에서 제외되길 원한게 아닐수도 있음. \n\n**해결**: Deep copy의 사용\n\n패키지 필요\n\n## 예제2\n\n`-` deepcopy\n\n묶음 방식이 달라지면서 다른 주소가 할당된 모습\n\n`-` 비교를 위한 shallow copy\n\n`-` 비교를 위한 참조 \n\n주소 다 똑같아\n\n# Shallow copy 연습문제 \n\n## 예제1\n\n`-` 아래의 코드결과를 예측하라. 결과가 나오는 이유를 설명하라. \n\nshallow copy 썼으니까 같이 추가된 모습\n\n## 예제2\n\n`-` 아래의 코드결과를 예측하라. 결과가 나오는 이유를 설명하라. \n\nl1에 재할당한 것이라 생각하면 된다.\n\n## 예제3\n\n## 예제4\n\n(잘못된 상상) 아래의 코드와 결과가 같을거야!!\n\n(하지만 현실은)\n\n재할당의 개념이 있었기 때문에 주소가 다른게 할당된 것이고, 결국 다른 결과가 나온다.\n\n## 예제5\n\n주소는 다르지만 재할당의 개념이 없어!\n\nl1에 append 하는 식으로 되어서 묶음 방식이 같이 움직인다.\n\n> ??? 예제4랑 예제5는 같은코드가 아니었음!!! `a += [1]` 는 새로운 오브젝트를 만드는게 아니고, 기존의 오브젝트를 변형하는 스타일의 코드였음! (마치 append 메소드처럼) \n\n# 불변형 객체 \n\n## Motivation example\n\n`-` 우리는 이제 아래의 내용은 마스터함 \n\n`-` 아래의 결과를 한번 예측해볼까? \n\n이번엔 튜플로\n\n## 해설 \n\n(시점1)\n\n이번엔 리스트 안에 튜플을 넣어봄\n\n(시점2)\n\n주소 `139753182280032`에 있는 값을 바꾸고 싶지만 불변형이라 못바꿈 $\\to$ 그냥 새로 만들자. 그래서 그걸 `139753174874064`에 저장하자. \n\n튜플의 묶음 방식은 불변형! 정의: 값을 변환할 수 없는 오브젝트다~ 새로 오브젝트 만들어 저장함.\n\n리스트 : 값을 바꿀 수 있는 오브젝트다, 묶음 방식을 바꿀 수 있다.\n\n# Shallow copy vs Deep copy\n\n`-` 암기용문구: \"shallow copy는 껍데기만 복사한다. deep copy는 내부까지 복사한다.\"\n\n`-` 일부교재에서는 경우에 따라 shallow copy가 선호될 수 있다는 식으로 설명되어있으나 솔직히 대부분 코드에서 shallow copy의 동작을 의도하고 코드를 사용하진 않는다. 대부분의 경우에서 shallow copy는 불필요한 side effect을 유발하는 쓸모없는 개념이라 생각한다. \n\n`-` 그럼 shallow copy의 장점은 무엇인가? shallow copy가 deep copy보다 메모리를 더 적게 사용한다. \n\n```Python\n## 예제1\nlst1 = ['양성준',['최규빈','이영미','최혜미']]\nlst2 = lst1.copy()\n## 예제2 \nlst1 = ['양성준',['최규빈','이영미','최혜미']]\nlst2 = copy.deepcopy(lst1)\n```\n\n- 예제1: 4+1+2 = 7개의 공간 사용 \n- 예제2: 4+2+2 = 8개의 공간 사용 \n\n`-` 분노: 참조인지 카피인지 구분하는것도 힘든데, 카피도 shallow 인지 deep 인지 구분해서 사용해야해? 겨우 저 메모리때문에? \n\n**요약**\n\n`-` 파이썬은 메모리를 아끼기 위해서 shallow copy라는 이상한 행동을 한다. \n\n`-` 통찰1: 그런데 오묘하게도 [1,2,3,4,5,6]와 같이 중첩된 리스트가 아니라면 문제가 되지 않음. (***메모리는 아끼면서 문제가 되지 않는다?? 천재인데??***) \n\n-  중첩된 리스트가 아닐 경우는 `shallow copy = deep copy` 임.\n\n1차원이면 이런 문제 생기지 않지, 하지만 모든 데이터가 1차원?\n\n`-` 통찰2: 생각해보니까 모든 자료형이 불변형인 경우에도 문제가 되지 않음. (R은 모든 자료형이 불변형이다) \n\n`-` 문제상황요약: [[1,2],[3,4]] 와 같이 리스트에 리스트가 포함된 형태라면 문제가 생긴다. (이건 개선이 필요함) \n- 개선1: 깊은복사(import copy)\n- 개선2: 넘파이\n\n# numpy \n\n## 2차원의 실체\n\n`-` 2차원 array a,b를 선언하자. \n\n`-` a,b,c,d 속성비교 \n\n`-` strides는 무엇? \n\n- strides: (다음 행으로 가기위해서 JUMP해야하는 메모리 공간수, 다음 열로 가기위해서 JUMP해야하는 메모리 공간수) \n\n`-` 사실 a,b,c,d 는 모두 1차원으로 저장되어있음. (중첩된 리스트꼴이 아니라)\n\nshape이나 strides 등의 옵션으로 1차원이 아니게 보여지는 것 뿐\n\n## 참조 \n\n`-` a를 선언, b는 a의 참조\n\n`-` a의 shape을 바꾸어보자 $\\to$ b도 같이 바뀐다 \n\n## view \n\n`-` a를 선언, b는 a의 view\n\nview가 shallow copy 같은 이유 껍데기 주소만 복사해옴, 공간에 대한 주소는 같지 않음\n\n`-` 그런데.. \n\n`-` 출생의 비밀 \n\n- ? 이거 바뀐 a아니야? \n\n`-` View \n- b가 a의 뷰라는 의미는, b가 a를 소스로하여 만들어진 오브젝트란 의미이다. \n- 따라서 이때 b.base는 a가 된다. \n- b는 자체적으로 데이터를 가지고 있지 않으며 a와 공유한다. \n- 이러한 의미에서 view를 shallow copy 라고 부른다. (stride, shape과 같은 껍데기만 새로 생성, base는 유지) \n\n`note1` 원본 ndarray의 일 경우는 .base가 None으로 나온다. \n\n`note2` b.base의 shpae과 b의 shape은 아무 관련없다. \n\n## copy \n\n`-` a를 선언, b는 a의 copy\n\n`-` a의 shape을 바꿔도 b에는 적용되지 않음 \n\n`-` 그리고 a[0]의 값을 바꿔도 b에는 적용되지 않음. \n\n`-` b의 출생을 조사해보니.. \n\n출생의 비밀은 없었다. 둘다 원본. \n\n`-` `.view()` 는 껍데기만, `.copy()` 는 껍데기 + base 까지 새로생성 \n\n### ***Appendix: .copy의 한계(?)***\n\n***해결책: 더 깊은 복사***\n\n`-` 중간요약\n\n- 사실 `.copy()`는 온전한 deep copy 가 아니라 level 2 deep copy 이다. \n- 따라서 `.copy()`는 base의 정보를 shallow copy 한다 (level 1 deep copy 한다.)\n- 그래서 base가 다시 중첩구조를 가지는 경우는 온전한 deep-copy가 수행되지 않는다. \n- 그런데 일반적으로 넘파이를 이용할때 자주 사용하는 데이터 구조인 행렬, 텐서등은 base가 중첩구조를 가지지 않는다. (1차원 array로만 저장되어 있음) \n- 따라서 행렬, 텐서에 한정하면 `.copy()`는 온전한 deep copy라고 이해해도 무방하다. \n\n행/열 같지 않으면 numpy쓰면 힘들걸..\n\n모든 데이터 구조가 2차원까지로 정리 된다.\n\n## 별명, 뷰, 카피 \n\n`-` test 함수 작성 \n\n`-` 잘 동작하나? \n\n(테스트1) \n\n참조\n\n(테스트2) \n\n(테스트3) \n\n(테스트4) \n\n## 결론 \n\n`-` 우리가 사용했던 어떠한 것들이 뷰가 나올지 카피가 나올지 사실 잘 모른다. (그래서 원리를 이해해도 대응할 방법이 사실없음) \n\n### 예시1\n\n### 예시2\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":true,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":false,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"jupyter"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":false,"code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../styles.css"],"toc":true,"output-file":"2022-12-07-13wk.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.4.315","theme":"pulse","code-copy":false,"title-block-banner":true,"comments":{"utterances":{"repo":"seoyeonc/md"}},"title":"A1: 깊은복사와 얕은복사 (12주차)","author":"SEOYEON CHOI","date":"2022-12-07","categories":["Special Topics in Machine Learning","깊은복사","얕은복사"]},"extensions":{"book":{"multiFile":true}}},"ipynb":{"identifier":{"display-name":"Jupyter","target-format":"ipynb","base-format":"ipynb"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"png","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":true,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":false,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"jupyter"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"ipynb","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":true,"merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"default-image-extension":"png","to":"ipynb","output-file":"2022-12-07-13wk.ipynb"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words"},"metadata":{"title-block-banner":true,"comments":{"utterances":{"repo":"seoyeonc/md"}},"title":"A1: 깊은복사와 얕은복사 (12주차)","author":"SEOYEON CHOI","date":"2022-12-07","categories":["Special Topics in Machine Learning","깊은복사","얕은복사"]}}},"projectFormats":["html"]}